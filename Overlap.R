library(hypervolume)
library(foreach)
library(doParallel)
source("Resample.R")

# overlap.test takes in one permutation or bootstrap file path, or a list of two boot strap file paths
# generates null distribution from hypervolume inputs and calculates p-value
# Run time decreases from a parallel backend
overlap.test <- function(hv1, hv2, path, alternative = "one-sided", bins = 100) {
  if(alternative != "one-sided" & alternative != "two-sided") {
    stop("invalid alternative hypothesis")
  }
  observed = hypervolume_overlap_statistics(hypervolume_set(hv1, hv2, check.memory = FALSE))
  if(length(path) == 1) {
    if(length(list.files(path)) == 0) {
      stop("Invalid input path")
    }
    if(list.files(path)[1] == "permutation1") {
      distribution = foreach(i = list.files(path), .combine = rbind) %dopar% {
        h1 = readRDS(file.path(path, i, "hv1.rds"))
        h2 = readRDS(file.path(path, i, "hv2.rds"))
        hypervolume_overlap_statistics(hypervolume_set(h1, h2, check.memory = FALSE))
      }
    } else if(list.files(path)[1] == "resample 1.rds") {
      files = list.files(path)
      half = floor(length(files)/2)
      distribution = foreach(i = 1:half, .combine = rbind) %:%
        foreach(j = (half+1):length(files), .combine = rbind) %dopar% {
          h1 = readRDS(file.path(path, files[i]))
          h2 = readRDS(file.path(path, files[j]))
          hypervolume_overlap_statistics(hypervolume_set(h1, h2, check.memory = FALSE))
        }
    } else {
      stop("Invalid input path")
    }
  } else if(length(path) == 2) {
    if(list.files(path[1])[1] == list.files(path[2])[1] & list.files(path[1])[1] == "resample 1.rds") {
      distribution = foreach(i = list.files(path[1]), .combine = rbind) %:%
        foreach(j = list.files(path[2]), .combine = rbind) %dopar% {
          h1 = readRDS(file.path(path[1], i))
          h2 = readRDS(file.path(path[2], j))
          hypervolume_overlap_statistics(hypervolume_set(h1, h2, check.memory = FALSE))
        }
    } else {
      stop("invalid input paths")
    }
  } else {
    stop("invalid input paths")
  }
  
  # Build list of useful results
  if(alternative == "one-sided") {
    p_values = list(
      "jaccard" = mean(distribution[,"jaccard"] <= observed["jaccard"]),
      "sorensen" = mean(distribution[,"sorensen"] <= observed["sorensen"]),
      "frac_unique_1" = mean(distribution[,"frac_unique_1"] >= observed["frac_unique_1"]),
      "frac_unique_2" = mean(distribution[,"frac_unique_2"] >= observed["frac_unique_2"])
    )
  } else if(alternative == "two-sided") {
    p_values = list(
      "jaccard" = mean(abs(distribution[,"jaccard"] - mean(distribution[,"jaccard"])) >= observed["jaccard"]),
      "sorensen" = mean(abs(distribution[,"sorensen"] - mean(distribution[,"sorensen"])) >= observed["sorensen"]),
      "frac_unique_1" = mean(abs(distribution[,"frac_unique_1"] - mean(distribution[,"frac_unique_1"])) >= observed["frac_unique_1"]),
      "frac_unique_2" = mean(abs(distribution[,"frac_unique_2"] - mean(distribution[,"frac_unique_2"])) >= observed["frac_unique_2"])
    )
  }
  plots = list(
    "jaccard" = ggplot(data.frame(distribution), aes(x = jaccard, y = ..density..)) + 
      geom_histogram(bins = bins) + 
      geom_point(aes(x = observed["jaccard"], y = 0), color = "red") + 
      ggtitle("Distribution of jaccard index"),
    "sorensen" = ggplot(data.frame(distribution), aes(x = sorensen, y = ..density..)) + 
      geom_histogram(bins = bins) + 
      geom_point(aes(x = observed["sorensen"], y = 0), color = "red") + 
      ggtitle("Distribution of sorensen index"),
    "frac_unique_1" = ggplot(data.frame(distribution), aes(x = frac_unique_1, y = ..density..)) + 
      geom_histogram(bins = bins) + 
      geom_point(aes(x = observed["frac_unique_1"], y = 0), color = "red") + 
      ggtitle("Distribution of fraction of Hypervolume 1 that is unique"),
    "frac_unique_2" = ggplot(data.frame(distribution), aes(x = frac_unique_2, y = ..density..)) + 
      geom_histogram(bins = bins) + 
      geom_point(aes(x = observed["frac_unique_2"], y = 0), color = "red") + 
      ggtitle("Distribution of fraction of Hypervolume 2 that is unique")
    )
  result = list(p_values = p_values, plots = plots, distribution = distribution)
  return(result)
}

# input are two bootstrap file path outputs from resample for two hypervolumes
# returns confidence interval and distribution of overlap statistics for hypervolumes used to generate bootstraps
overlap.confidence <- function(path1, path2, CI = .95) {
  if(list.files(path1)[1] != "resample 1.rds" | list.files(path2)[1] != "resample 1.rds") {
    stop("Invalid input")
  }
  distribution = foreach(i = list.files(path1), .combine = rbind) %:%
    foreach(j = list.files(path2), .combine = rbind) %dopar% {
      h1 = readRDS(file.path(path1, i))
      h2 = readRDS(file.path(path2, j))
      hypervolume_overlap_statistics(hypervolume_set(h1, h2, check.memory = FALSE))
    }
  results = list(
    "jaccard" = quantile(distribution[,"jaccard"], c(.5 - CI/2, .5 + CI/2)),
    "sorensen" = quantile(distribution[,"sorensen"], c(.5 - CI/2, .5 + CI/2)),
    "frac_unique_1" = quantile(distribution[,"frac_unique_1"], c(.5 - CI/2, .5 + CI/2)),
    "frac_unique_2" = quantile(distribution[,"frac_unique_2"], c(.5 - CI/2, .5 + CI/2)),
    "distribution" = distribution
  )
  return(results)
}
